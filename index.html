<!DOCTYPE html>
<html lang="ja">
<head>
  <script src="matter.min.js"></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ã„ã‚ã¯ãƒ»ã‚†ã†ã‚Šãƒ»ãªãã•ãƒ»ã¤ã‚ˆã—ãƒ»ã‚Šã• â€” ã™ã„ã‹ã‚²ãƒ¼ãƒ é¢¨</title>
  <style>
    :root { --bg:#0b132b; --panel:#1c2541; --accent:#5bc0be; --text:#f2f7ff; --warn:#ff8c8c; }
    html,body{ margin:0; height:100%; background:var(--bg); color:var(--text);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; touch-action:none;}
    .wrap{ display:grid; grid-template-rows:auto 1fr auto; place-items:center; gap:8px; padding:8px; height:100%; box-sizing:border-box;}
    .topbar{ width:min(440px,92vw); background:linear-gradient(180deg,#222b4d,var(--panel)); border:1px solid #2e3a63; border-radius:14px;
      padding:8px 12px; display:grid; grid-template-columns:1fr auto auto auto; align-items:center; gap:10px; box-shadow:0 8px 24px rgba(0,0,0,.2);}
    .brand{ font-weight:700; letter-spacing:.03em;} .score{ font-variant-numeric:tabular-nums; padding:4px 8px; border-radius:8px; background:#121a34; border:1px solid #2a3560;}
    .nextbox{ display:grid; grid-template-columns:auto auto; gap:8px; align-items:center;} .nextbox small{opacity:.8;}
    #nextCanvas{ width:40px; height:40px; background:#0f1630; border:1px solid #2a3560; border-radius:8px;}
    button,.btn{ appearance:none; color:var(--text); background:var(--accent); border:none; border-radius:10px; padding:8px 12px; font-weight:700; cursor:pointer; box-shadow:0 6px 18px rgba(91,192,190,.35);}
    button:active{ transform:translateY(1px);} #stageWrap{ position:relative;}
    #stage{ display:block; width:min(440px,92vw); height:calc(min(440px,92vw)*1.5); max-height:88vh;
      background:radial-gradient(1200px 400px at 50% -200px,#20305e,#0b132b 60%); border:1px solid #2a3560; border-radius:16px; box-shadow:inset 0 4px 24px rgba(0,0,0,.35),0 12px 28px rgba(0,0,0,.35);}
    .hud{ position:absolute; inset:0; pointer-events:none; border-radius:16px;} .line{ position:absolute; left:8px; right:8px; height:0; border-top:2px dashed rgba(255,255,255,.25);}
    .line.top{ top:64px;} .line.lose{ top:104px; border-top-color:var(--warn);} .goPanel{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;
      background:linear-gradient(180deg,rgba(11,19,43,0),rgba(11,19,43,.55)); opacity:0; transition:opacity .25s ease;} .goPanel.show{opacity:1;}
    .goCard{ pointer-events:auto; padding:16px 18px; border-radius:16px; text-align:center; width:min(360px,90%); backdrop-filter:blur(8px);
      background:rgba(18,26,52,.92); border:1px solid #2a3560; box-shadow:0 14px 40px rgba(0,0,0,.5);} .footer{opacity:.7; font-size:12px;} a{color:#8fd6d4;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">ğŸ‰ ã™ã„ã‹ã‚²ãƒ¼ãƒ é¢¨ï¼ˆã„ã‚ã¯â†’ã‚†ã†ã‚Šâ†’ãªãã•â†’ã¤ã‚ˆã—â†’ã‚Šã•ï¼‰</div>
      <div class="nextbox"><small>NEXT</small><canvas id="nextCanvas" width="40" height="40"></canvas></div>
      <div class="score">SCORE <span id="score">0</span></div>
      <button id="restartBtn" title="R ã‚­ãƒ¼ã§ã‚‚å†é–‹">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>

    <div id="stageWrap">
      <canvas id="stage"></canvas>
      <div class="hud">
        <div class="line top" title="ã“ã“ã‚ˆã‚Šä¸Šã§ç©ã‚€ã¨å±é™ºã‚¾ãƒ¼ãƒ³"></div>
        <div class="line lose" title="ã“ã“ã‚’è¶…ãˆã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼"></div>
      </div>
      <div class="goPanel" id="goPanel">
        <div class="goCard">
          <h2 style="margin:6px 0 10px">Game Overâ€¦</h2>
          <p style="margin:0 0 12px">ã‚Šã•Ã—2ã§æ¶ˆãˆã‚‹ã‚ˆã€‚ç”»é¢ã‚¿ãƒƒãƒ— / ã‚¹ãƒšãƒ¼ã‚¹ã§è½ä¸‹ã€å·¦å³ã«æŒ‡/ãƒã‚¦ã‚¹ã§ä½ç½®èª¿æ•´ã€‚</p>
          <p style="margin:0 0 14px">ã‚¹ã‚³ã‚¢ï¼š<b id="finalScore">0</b></p>
          <button id="againBtn">ã‚‚ã†ä¸€åº¦ã‚ãã¶</button>
        </div>
      </div>
    </div>

    <div class="footer">
      <p style="margin:0">å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã§å‹•ä½œï¼GitHub Pages ç›´ç½®ãOKã€‚ç”»åƒã«å·®ã—æ›¿ãˆã‚‹å ´åˆã¯ <code>assets/iroha.png, yuri.png, nagisa.png, tsuyoshi.png, risa.png</code> ã‚’ç½®ãã€<code>USE_IMAGES = true</code> ã«ã—ã¦ãã ã•ã„ã€‚</p>
    </div>
  </div>

  <script>
    window.addEventListener('load', () => {
      const USE_IMAGES = true;

      const imageFiles = {
        0:'assets/iroha.png', 1:'assets/yuri.png', 2:'assets/nagisa.png', 3:'assets/tsuyoshi.png', 4:'assets/risa.png'
      };
      const images = {};
      if (USE_IMAGES) for (const k of Object.keys(imageFiles)){ const img=new Image(); img.src=imageFiles[k]; images[k]=img; }

      const NAMES = ['ã„ã‚ã¯','ã‚†ã†ã‚Š','ãªãã•','ã¤ã‚ˆã—','ã‚Šã•'];
      const TIERS = [
        { name:NAMES[0], r:16, color:'#ffadad', score:1 },
        { name:NAMES[1], r:22, color:'#ffd6a5', score:3 },
        { name:NAMES[2], r:30, color:'#fdffb6', score:6 },
        { name:NAMES[3], r:40, color:'#caffbf', score:12 },
        { name:NAMES[4], r:54, color:'#a0c4ff', score:25 },
      ];
      const BONUS_CLEAR = 100;

      const stage = document.getElementById('stage');
      const nextCanvas = document.getElementById('nextCanvas');
      const nextCtx = nextCanvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const restartBtn = document.getElementById('restartBtn');
      const goPanel = document.getElementById('goPanel');
      const againBtn = document.getElementById('againBtn');
      const finalScoreEl = document.getElementById('finalScore');

      const WIDTH = Math.min(440, Math.floor(window.innerWidth*0.92));
      const HEIGHT = Math.min(720, Math.floor(WIDTH*1.5));
      stage.width = WIDTH; stage.height = HEIGHT;

      const SPAWN_Y = 160;
      const LOSE_Y = 104;

      const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

      const engine = Engine.create(); engine.gravity.y = 1.05;
      const render = Render.create({ canvas:stage, engine, options:{ width:WIDTH, height:HEIGHT, wireframes:false, background:'transparent' }});
      Render.run(render); const runner = Runner.create(); Runner.run(runner, engine);

      const wallT = 40;
      const walls = [
        Bodies.rectangle(WIDTH/2, HEIGHT + wallT/2 - 8, WIDTH-16, wallT, { isStatic:true, render:{ fillStyle:'#132048' } }),
        Bodies.rectangle(-wallT/2 + 8, HEIGHT/2, wallT, HEIGHT-16, { isStatic:true, render:{ fillStyle:'#162350' } }),
        Bodies.rectangle(WIDTH + wallT/2 - 8, HEIGHT/2, wallT, HEIGHT-16, { isStatic:true, render:{ fillStyle:'#162350' } }),
        Bodies.rectangle(WIDTH/2, -wallT/2, WIDTH, wallT, { isStatic:true, render:{ fillStyle:'transparent' } }),
      ];
      World.add(engine.world, walls);

      let currentX = WIDTH/2;
      let currentTier = rollTier();
      let nextTier = rollTier();
      let score = 0;
      let gameOver = false;
      let dropCooldown = false;

      drawNextPreview(nextTier);

      const clamp=(v,min,max)=>Math.min(Math.max(v,min),max);
      function setXFromClient(clientX){ const rect=stage.getBoundingClientRect(); const x=((clientX-rect.left)/rect.width)*WIDTH; currentX=clamp(x,24,WIDTH-24); }
      stage.addEventListener('pointermove', e=>setXFromClient(e.clientX));
      stage.addEventListener('pointerdown', e=>{ setXFromClient(e.clientX); tryDrop(); });
      window.addEventListener('keydown', e=>{
        if (e.code==='ArrowLeft')  currentX=clamp(currentX-18,24,WIDTH-24);
        if (e.code==='ArrowRight') currentX=clamp(currentX+18,24,WIDTH-24);
        if (e.code==='Space' || e.code==='Enter') tryDrop();
        if (e.key==='r' || e.key==='R') restart();
      }, { passive:false });
      restartBtn.addEventListener('click', restart);
      againBtn.addEventListener('click', restart);

      function tryDrop(){ if (gameOver||dropCooldown) return; dropCooldown=true; setTimeout(()=>dropCooldown=false,120);
        dropPiece(currentTier,currentX,SPAWN_Y); currentTier=nextTier; nextTier=rollTier(); drawNextPreview(nextTier); }
      function rollTier(){ const bag=[0,0,0,1,1,2]; return bag[Math.floor(Math.random()*bag.length)]; }

      function createPiece(tier,x,y){
        const t=TIERS[tier];
        const body=Bodies.circle(x,y,t.r,{ restitution:0.05, friction:0.12, frictionAir:0.0025, density:0.0018*(1+tier*0.22),
          render:{ fillStyle:t.color, strokeStyle:'#2a2a2a', lineWidth:1 }});
        body.plugin={ tier, removed:false, bornAt:performance.now() }; return body;
      }
      function dropPiece(tier,x,y){ World.add(engine.world, createPiece(tier,x,y)); }
      function addScore(v){ score+=v; scoreEl.textContent=score; }

      const mergeKeys=new Set();
      Events.on(engine,'collisionStart',e=>{
        for(const p of e.pairs){
          const a=p.bodyA,b=p.bodyB;
          if(!a.plugin||!b.plugin) continue;
          if(a.plugin.removed||b.plugin.removed) continue;
          if(a.plugin.tier===undefined||b.plugin.tier===undefined) continue;
          if(a.plugin.tier!==b.plugin.tier) continue;
          if(a.isStatic||b.isStatic) continue;
          const now=performance.now();
          if(now-a.plugin.bornAt<80||now-b.plugin.bornAt<80) continue;
          const key=[a.id,b.id].sort().join('-'); if(mergeKeys.has(key)) continue;
          mergeKeys.add(key); queueMerge(a,b);
        }
      });
      function queueMerge(a,b){ setTimeout(()=>doMerge(a,b),0); }
      function doMerge(a,b){
        try{
          if(!Composite.get(engine.world,a.id,'body')||!Composite.get(engine.world,b.id,'body')) return;
          if(a.plugin.removed||b.plugin.removed) return;
          const tier=a.plugin.tier; const nx=(a.position.x+b.position.x)/2; const ny=(a.position.y+b.position.y)/2;
          a.plugin.removed=b.plugin.removed=true; World.remove(engine.world,a); World.remove(engine.world,b);
          if(tier<TIERS.length-1){ World.add(engine.world,createPiece(tier+1,nx,ny)); addScore(TIERS[tier+1].score); }
          else { addScore(BONUS_CLEAR); burst(nx,ny,10); }
          checkGameOver();
        } finally { mergeKeys.clear(); }
      }

      function burst(x,y,n){
        for(let i=0;i<n;i++){
          const r=2+Math.random()*3;
          const p=Bodies.circle(x,y,r,{ restitution:0.6, friction:0.02, density:0.0008,
            render:{ fillStyle:['#fff','#8fd6d4','#ffd6a5','#caffbf'][i%4] }});
          Body.setVelocity(p,{ x:(Math.random()-0.5)*6, y:-Math.random()*6-2 });
          World.add(engine.world,p);
          setTimeout(()=>{ try{ World.remove(engine.world,p); }catch{} },1500+Math.random()*500);
        }
      }

      Events.on(render,'afterRender',()=>{
        const ctx=render.context;
        const bodies=Composite.allBodies(engine.world);
        for(const body of bodies){
          if(!body.plugin||body.plugin.tier===undefined) continue;
          const t=TIERS[body.plugin.tier]; const {x,y}=body.position;
          ctx.save(); ctx.translate(x,y); ctx.rotate(body.angle);
          if(USE_IMAGES && images[body.plugin.tier] && images[body.plugin.tier].complete){
            ctx.beginPath(); ctx.arc(0,0,t.r,0,Math.PI*2); ctx.closePath(); ctx.clip();
            const img=images[body.plugin.tier]; const s=t.r*2; ctx.drawImage(img,-s/2,-s/2,s,s);
          } else {
            ctx.fillStyle='#1a1a1a'; ctx.font=`bold ${Math.max(12,Math.floor(t.r*0.9))}px system-ui, sans-serif`;
            ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(t.name,0,1);
          }
          ctx.restore();
        }
        if(!gameOver){
          const t=TIERS[currentTier];
          ctx.save(); ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,.6)'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.arc(currentX,SPAWN_Y,t.r,0,Math.PI*2); ctx.stroke(); ctx.restore();
        }
      });

      let frame=0;
      Events.on(engine,'afterUpdate',()=>{ frame++; if(frame%6!==0) return; checkGameOver(); });

      function checkGameOver(){
        if(gameOver) return;
        const now=performance.now(); const bodies=Composite.allBodies(engine.world);
        let minTop=Infinity;
        for(const body of bodies){
          if(!body.plugin||body.plugin.tier===undefined) continue;
          const age=now-(body.plugin.bornAt||0); const settled=body.speed<0.12;
          if(age<900||!settled) continue;
          const r=TIERS[body.plugin.tier].r; const top=body.position.y-r;
          if(top<minTop) minTop=top;
        }
        if(minTop<LOSE_Y){ gameOver=true; finalScoreEl.textContent=score; goPanel.classList.add('show'); }
      }

      function restart(){
        const all=Composite.allBodies(engine.world);
        for(const b of all){ if(!walls.includes(b)) try{ World.remove(engine.world,b);}catch{} }
        score=0; scoreEl.textContent='0'; currentTier=rollTier(); nextTier=rollTier(); drawNextPreview(nextTier);
        gameOver=false; goPanel.classList.remove('show');
      }

      function drawNextPreview(tier){
        const t=TIERS[tier];
        nextCtx.clearRect(0,0,40,40);
        nextCtx.save(); nextCtx.translate(20,20);
        nextCtx.beginPath(); nextCtx.arc(0,0,14,0,Math.PI*2);
        nextCtx.fillStyle=t.color; nextCtx.fill();
        nextCtx.strokeStyle='#2a2a2a'; nextCtx.lineWidth=1; nextCtx.stroke();
        nextCtx.fillStyle='#1a1a1a'; nextCtx.font='bold 10px system-ui, sans-serif';
        nextCtx.textAlign='center'; nextCtx.textBaseline='middle'; nextCtx.fillText(t.name,0,0);
        nextCtx.restore();
      }

      currentX = WIDTH/2;
    });
  </script>
</body>
</html>
